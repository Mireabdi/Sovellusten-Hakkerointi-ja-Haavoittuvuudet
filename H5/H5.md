### Sovellusten Hakkerointi ja Haavoittuvaisuudet

## ICI012AS3A

## Abdirahman Mire

# H5 Se elää!

### Työympäristö:

Käyttöjärjestelmä: Windows 11 Pro 64-bit

CPU: Intel Core i7-12700KF - 4 cores in use

RAM: 6 GB DDR4

Disk: 80gb

Virtuaalikone: VMware, Kali Linux

## lab 0

Latasin tehtävän ja unzippasin lab0 

![kuva1](/H5/kuva1.png)

Seuraavaksi käänsin ohjelman debug-symbolien kanssa:

`gcc -g -O0 buggy_program.c -o buggy_program`

Avasin gdp komennolla: 

`gdp  ./buggy_program`

`lay next`

![kuva1](/H5/kuva2.png)

Tein breakpointin funktiolle:

`break buggy_function` 

Suoritin ohjelman:

`run`

Tarkistin talukon koon:

`print size`

Tämä kertoo että talukossa on 5 elementtiä

![kuva1](/H5/kuva3.png)

Seurasin silmukkaa watch komennolla : 

`watch i` 

`continue` tai lyhyesti `c`

Tämä pysäytti silmukan jokaisella indeksin muutoksella. laitoin aina `c` ja `print arr[i]`.

Bugi tapahtui kun i = 5 sillä tämä oli taulukon ulkopuolella. Kaikki muut i = 0...4 olivat taulukon sisällä jonka takia toimivat oikein.

![kuva1](/H5/kuva4.png)

Silmukan <= size ehto salli yhden ylimääräisen askeleen. Korjasin vaihtamalla <= tähän: <

![kuva1](/H5/kuva5.png)

käänsin uudelleen: `gcc -g -O0 buggy_program.c -o buggy_program`

ja suoritin ohjelman: 

![kuva1](/H5/kuva6.png)


## Lab01

Aloitin `unzip lab1.zip` avasin ja siirryin gdp `gdp ./gdb_example1`  `lay next` 

kuva7

Käytin komentoa `run` joka antoi tulostuksen: Program received signal SIGSEGV, segmentation fault.

kuva8

Wikipedian mukaan: Segmentation fault (SIGSEGV) on virhe, joka syntyy, kun ohjelma yrittää käyttää muistia, johon sillä ei ole oikeutta, esimerkiksi dereferoimalla NULL-osoitinta tai käyttämällä taulukon ulkopuolista indeksiä.

Käytin seuraavaksi komentoa `backtrace` joka kertoo mikä funktio ja rivi aiheuttaa bugin.

kuva9

Näyttää että funktio `print_scrambled` aiheuttaa kaatumisen.

Käytin vielä komentoa `print message`:

kuva10

Ohjelma kaatuu, koska yritetään käyttää muistin paikkaa jota ei ole olemassa.

Ryhdyin korjaamaan koodia käyttäen tekoälyä:

micro gdb_example1.c

kuva11
kuva12

Funktio print_scrambled tarkistaa ensin, onko annettu merkkijono NULL. Jos on, se tulostaa (null message) ja lopettaa. Muuten se lisää jokaisen merkin arvoon 3 ja tulostaa tuloksen. Näin ohjelma käsittelee merkkijonot turvallisesti eikä kaadu.

käänsin vielä ohjelman:

`gcc -g -O0 lab1.c -o lab1_program`

ja ajoin ohjelman: `./gdb_example1`: 

kuva13






