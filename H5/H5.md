### Sovellusten Hakkerointi ja Haavoittuvaisuudet

## ICI012AS3A

## Abdirahman Mire

# H5 Se elää!

### Työympäristö:

Käyttöjärjestelmä: Windows 11 Pro 64-bit

CPU: Intel Core i7-12700KF - 4 cores in use

RAM: 6 GB DDR4

Disk: 80gb

Virtuaalikone: VMware, Kali Linux

## lab 0

Latasin tehtävän ja unzippasin lab0 

![kuva1](/H5/kuva1.png)

Seuraavaksi käänsin ohjelman debug-symbolien kanssa:

`gcc -g -O0 buggy_program.c -o buggy_program`

Avasin gdp komennolla: 

`gdp  ./buggy_program`

`lay next`

![kuva1](/H5/kuva2.png)

Tein breakpointin funktiolle:

`break buggy_function` 

Suoritin ohjelman:

`run`

Tarkistin talukon koon:

`print size`

Tämä kertoo että talukossa on 5 elementtiä

![kuva1](/H5/kuva3.png)

Seurasin silmukkaa watch komennolla : 

`watch i` 

`continue` tai lyhyesti `c`

Tämä pysäytti silmukan jokaisella indeksin muutoksella. laitoin aina `c` ja `print arr[i]`.

Bugi tapahtui kun i = 5 sillä tämä oli taulukon ulkopuolella. Kaikki muut i = 0...4 olivat taulukon sisällä jonka takia toimivat oikein.

![kuva1](/H5/kuva4.png)

Silmukan <= size ehto salli yhden ylimääräisen askeleen. Korjasin vaihtamalla <= tähän: <

![kuva1](/H5/kuva5.png)

käänsin uudelleen: `gcc -g -O0 buggy_program.c -o buggy_program`

ja suoritin ohjelman: 

![kuva1](/H5/kuva6.png)


## Lab01

Aloitin `unzip lab1.zip` avasin ja siirryin gdp `gdp ./gdb_example1`  `lay next` 

![kuva1](/H5/kuva7.png)

Käytin komentoa `run` joka antoi tulostuksen: Program received signal SIGSEGV, segmentation fault.

![kuva1](/H5/kuva8.png)

Wikipedian mukaan: Segmentation fault (SIGSEGV) on virhe, joka syntyy, kun ohjelma yrittää käyttää muistia, johon sillä ei ole oikeutta, esimerkiksi dereferoimalla NULL-osoitinta tai käyttämällä taulukon ulkopuolista indeksiä.

Käytin seuraavaksi komentoa `backtrace` joka kertoo mikä funktio ja rivi aiheuttaa bugin.

![kuva1](/H5/kuva9.png)

Näyttää että funktio `print_scrambled` aiheuttaa kaatumisen.

Käytin vielä komentoa `print message`:

![kuva1](/H5/kuva10.png)

Ohjelma kaatuu, koska yritetään käyttää muistin paikkaa jota ei ole olemassa.

Ryhdyin korjaamaan koodia käyttäen tekoälyä:

`micro gdb_example1.c`

![kuva1](/H5/kuva11.png)
![kuva1](/H5/kuva12.png)

Funktio print_scrambled tarkistaa ensin, onko annettu merkkijono NULL. Jos on, se tulostaa (null message) ja lopettaa. Muuten se lisää jokaisen merkin arvoon 3 ja tulostaa tuloksen. Näin ohjelma käsittelee merkkijonot turvallisesti eikä kaadu.

käänsin vielä ohjelman:

`gcc -g -O0 lab1.c -o lab1_program`

ja ajoin ohjelman: `./gdb_example1`: 

![kuva1](/H5/kuva13.png)


## Lab2

passtr ohjelman salasana löytyi `gdp ./passtr`

kuva 14
kuva15

Mutta epäilen kyllä että tuo on varsinainen tehtävä. kansio sisältää myös Passtr2o jolla ei ole lähdekoodia ollenkaan. 
yritin sitäkin ratkoa ilman tulosta. Avattuani gdbssä `break main` , `run` ja pienellä goolailulla löysin seuraavan komennon  `disassemble main`

kuva16 
tässä nyt tätä katselin mutta ei harmaintakaan aavistusta miten tässä pitäisi salasana ja flagi löytää

#### Referenssit

wikipedia: https://en.wikipedia.org/wiki/Segmentation_fault

https://www.youtube.com/watch?v=Qr9jKw3YKtw

https://www.youtube.com/watch?v=Dq8l1_-QgAc

gpt: chatgpt.com
